---
layout: post
title: 정보처리기사_요구사항확인_Chapter2
slug: 정보처리기사_요구사항확인_Chapter2
categories: certificate
tags: 정보처리기사
description: >
  정보처리기사 현행 시스템 분석
published: false
---

# Chapter02. 현행 시스템 분석

## 1. 현행 시스템 파악⭐⭐⭐

### (1) 현행 시스템 파악 개념

- 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지 파악하는 활동

### (2) 현행 시스템 파악 절차

- 구성/기능/인터페이스 파악 → 아키텍처 및 소프트웨어 구성 파악 → 하드웨어 및 네트워크 구성 파악
1. **현행 시스템 구성/기능 및 인터페이스 파악**
    - 시스템 구성 현황 파악
    - 시스템 기능 파악
    - 시스템 인터페이스 현황 파악
2. **현행 시스템 아키텍처 및 소프트웨어 구성 파악**
    - 아키텍처 파악
    - 소프트웨어 구성 파악
3. **하드웨어 및 네트워크 구성 파악**
    - 시스템 하드웨어 현황 파악
    - 네트워크 구성 파악

### (3) 소프트웨어 아키텍처

1. **소프트웨어 아키텍처(Software Architecture) 개념**
    - 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체
2. **소프트웨어 아키텍처 프레임워크**
    1. 소프트웨어 아키텍처 프레임워크(Software Architecture Framework) 개념
        - 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준
        - IEEE 1471
    2. 소프트웨어 아키텍처 프레임워크 구성요소
        1. 아키텍처 명세서(Architectural Description)
        2. 이해관계자(Stakeholder)
        3. 관심사(Concerns)
        4. 관점(Viewpoint)
        5. 뷰(View)
        6. 근거(Rationale)
        7. 목표(Mission)
        8. 환경(Environment)
        9. 시스템(System)
3. **소프트웨어 아키텍처 4+1 뷰**
    1. 소프트웨어 아키텍처 4+1 뷰 개념
        - 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
        - 유스케이스 사용
    2. 소프트웨어 아키텍처 4+1 뷰 구성요소
        - **유논프구배**
        - 1은 유스케이스 뷰, 4는 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰
        - 유스케이스 뷰
            - 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰
            - 사용자, 설계자, 개발자, 테스트 관점
        - 논리 뷰
            - 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
            - 설계자, 개발자 관점
        - 프로세스 뷰
            - 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
            - 개발자, 시스템 통합자 관점
        - 구현 뷰
            - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
            - 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
        - 배포 뷰
            - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰
4. **소프트웨어 아키텍처 패턴**
    1. 소프트웨어 아키텍처 패턴(Software Architecture Pattern) 개념
    2. 소프트웨어 아키텍처 패턴 필요성
        - 요구사항 만족, 생산성 및 품질 확보, 개발 시간 단축, 개발을 안정적으로 수행, 시스템 특성 사전 예측 가능
    3. 소프트웨어 아키텍처 패턴 유형
        1. 계층화 패턴(Layered Pattern)
            - 시스템을 계층으로 구분하여 구성하는 패턴
            - 서로 마주보는 두 개의 계층 사이에서만 상호 작용이 이뤄짐
        2. 클라이언트-서버 패턴(Client-Server Pattern)
            - 하나의 서버, 다수의 클라이언트
        3. 파이프-필터 패턴(Pipe-Filter Pattern)
            - 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능
            - 서브 시스템이 처리하고 다음 서브 시스템으로 넘겨주는 과정 반복
        4. 브로커 패턴(Broker Pattern)
            - 분리된 컴포넌트로 이루어진 분산 시스템에서 사용됨
            - 서버가 자신의 기능을 브로커에 넘겨주며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 자신의 레지스트리에 있는 적합한 서비스로 리다이렉션(Redirection)함
        5. 모델-뷰-컨트롤러 패턴(MVC; Model View Controller Pattern)
            - 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴
5. **소프트웨어 아키텍처 비용 평가 모델**
    1. 소프트웨어 아키텍처 비용 평가 모델 개념
    2. 소프트웨어 아키텍처 비용 평가 모델 종류
        1. SAAM(Software Architecture Analysis Method)
        2. ATAM(Architecture Trade-off Analysis Method)
        3. CBAM(Cost Benefit Analysis Method)
        4. ADR(Active Design Review)
        5. ARID(Active Reviews for Intermediate Designs)

### (4) 디자인 패턴

1. **디자인 패턴(Design Pattern) 개념**
    - 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
    - 개발의 효율성, 유지보수성, 운용성 상승, 최적화에 도움
2. **디자인 패턴 구성요소**
    - **패문솔 사결샘**
    1. 패턴의 이름
    2. 문제 및 배경
    3. 솔루션
    4. 사례
    5. 결과
    6. 샘플 코드
3. **디자인 패턴 유형**🎯
    1. 목적 (**생구행**)
        1. 생성 : 객체 인스턴스 생성에 관여, 객체의 생성절차를 추상화
            
            → 객체를 어떻게 생성할 것인가?
            
        2. 구조 : 더 큰 구조 형성을 목적으로 클래스나 객체의 조합을 다루는 패턴
            
            → 생성된 객체를 어떻게 조합/합성할 것인가?
            
        3. 행위 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
            
            → 객체들이 어떻게 상호작용하고 어떻게 책임을 가져가는가?
            
    2. 범위
        1. 클래스 : 클래스 간 관련성, 컴파일 타임에 정적으로 결정
        2. 객체 : 객체 간 관련성, 런타임에 동적으로 결정
4. **디자인 패턴 종류**🎯
    1. 생성 패턴(**생빌 프로 팩앱싱**)
        1. Builder : 생성과 표기를 분리해서 복잡한 객체를 생성
        2. Prototype : 원형(프로토타입)을 만들어놓고 기존 객체를 복제함으로써 객체를 생성
        3. Factory Method : 상위 클래스에서는 인스턴스를 만드는 방법만 결정, 하위 클래스에서 객체를 생성
        4. Abstract Factory : 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공
        5. Singleton : 객체를 하나만 생성하도록 하여 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
    2. 구조 패턴(**구 브데 퍼플 프록 컴 어**)
        1. Bridge : 기능의 클래스 계층과 구현의 클래스 계층 연결, 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
        2. Decorator : 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴
        3. Facade : 복잡한 시스템에 대하여 단순한 인터페이스를 제공
        4. Flyweight : 다수의 객체가 공통적으로 갖는 본질적인 요소를 클래스 화하여 공유 → ‘클래스의 경량화’
        5. Proxy : ‘대리 객체’, 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만듦
        6. Composite : 객체들의 관계를 트리 구조로 구성, 부분-전체 계층 표현, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
        7. Adapter : 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
    3. 행위 패턴(**행 미인이 템옵 스테 비커 스트 메체**)
        1. Mediator : 중간에 통제와 지시하는 역할을 하는 중재자를 두어 중재자에게 모든 것을 요구 → 통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 패턴
        2. Interpreter : 언어를 구문으로 나누고 각각 구문의 해석을 맡는 클래스를 작성, 여러 형태의 언어 구문을 해석할 수 있게 만듦
        3. Iterator : 내부구조를 노출하지 않고 복합 객체의 원소를 순차적으로 접근 가능하게 해주는 패턴
        4. Template Method : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화 해 전체 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
        5. Observer : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들도 자동으로 내용이 갱신되는 방법
        6. State : 객체의 상태에 따라 행위 내용을 변경
        7. Visitor : 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴
        8. Command : 실행될 기능을 캡슐화함, 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 패턴
        9. Strategy : 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
        10. Memento : 객체의 정보를 저장할 필요가 있을 때 적용하는 패턴, Undo 가능
        11. Chain of Responsibility : 어떤 기능에 대한 처리가 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴, 한 요청을 2개 이상의 객체에서 처리

### (5) 현행 시스템 분석서 작성 및 검토

1. **현행 시스템 관련 자료 수집**
2. **수집 자료의 분석**
3. **분석한 결과를 기반으로 산출물 작성**
    - **현기인 아소하네**
    1. 정보시스템 구성 현황
    2. 정보시스템 기능 구성도
    3. 인터페이스 현황
    4. 현행 시스템 아키텍처 구성도
    5. 소프트웨어 구성도
    6. 하드웨어 구성도
    7. 네트워크 구성도
4. **산출물에 대한 검토 수행**

## 2. 개발 기술 환경 정의⭐⭐⭐

### (1) 개발 기술 환경 현행 시스템 분석

1. **운영체제 현행 시스템 분석**
    1. 운영체제(Operating System)의 개념
    2. 운영체제 현행 시스템 분석
        1. 품질 측면
            1. 신뢰도
            2. 성능
        2. 지원 측면
            1. 기술 지원
            2. 주변 기기
            3. 구축 비용
    3. 운영체제 종류 및 특징🎯
        1. PC
            1. 윈도우즈
            2. 유닉스
            3. 리눅스 : 소유 비용이 가장 적게 소요됨
        2. 모바일
            1. 안드로이드
            2. iOS
2. **네트워크 현행 시스템 분석**
    1. 네트워크(Network)의 개념
    2. OSI 7계층 (**아파서 티내다 피**)
        1. 응용 계층(Application Layer)
        2. 표현 계층(Presentation Layer)
        3. 세션 계층(Session Layer)
        4. 전송 계층(Transport Layer)
        5. 네트워크 계층(Network Layer)
        6. 데이터 링크 계층(Data Link Layer)
        7. 물리 계층(Physical Layer)
    3. 네트워크 현행 시스템 분석
3. **DBMS 현행 시스템 분석**
    1. DBMS(Database Management System)의 개념
    2. DBMS의 기능
        1. 중복 제어
        2. 접근 통제
        3. 인터페이스 제공
        4. 관계 표현
        5. 샤딩/파티셔닝
        6. 무결성 제약 조건
        7. 백업 및 회복
    3. DBMS 현행 시스템 분석 
        - **가성호기구**
        1. 가용성 
        2. 성능 
        3. 상호 호환성 
        4. 기술 지원 
        5. 구축 비용
4. **미들웨어의 현행 시스템 분석**
    1. 미들웨어(Meddleware)의 개념
        - 대표적인 미들웨어 WAS
    2. 웹 애플리케이션 서버(WAS; Web Application Server)의 개념
    3. 미들웨어의 현행 시스템 분석
        1. 성능 측면
            1. 가용성
            2. 성능
        2. 지원 측면
            1. 기술 지원
            2. 구축 비용
5. **오픈 소스 사용 시 고려 사항**

### (2) 개발 기술 환경 요구사항 파악

1. **기술 환경 정의를 위한 자료 수집**
2. **조사 자료 분석 및 개발 기술 환경 결정**
3. **요구사항 정의서, 목표 시스템 구성도 반영 및 검토**