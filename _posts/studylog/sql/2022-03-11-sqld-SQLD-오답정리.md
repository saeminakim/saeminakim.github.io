---
layout: post
title: SQLD 오답 정리
slug: SQLD 오답 정리
categories: studylog
tags: SQL, SQLD
description: >
  SQL 오답 정리 
---
# SQLD 오답 정리

### 데이터 모델과 성능

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff6a0dea-5158-4495-8edc-fc85ac5b8950/Untitled.png)

- 부분키 종속을 정규화 해야하는 상태 → 2차 정규화
- 관서번호와 납부자번호에 대한걸 각각 다른 테이블로 분리해야 함

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16b6048d-b30d-4a95-8a36-fb5e30222069/Untitled.png)

- 컬럼 단위에서 중복된 경우도 1차 정규화 대상

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3357d25a-811b-402b-85b6-7cc5c0db4199/Untitled.png)

- 반정규화(역정규화, De-Normalization)
    
    : 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능 향상과 개발, 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
    
    : 데이터 무결성이 깨질 수 있는 위험성이 있는 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 컬럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 수행
    
    : 프로젝트 설계단계에서 적용
    
- 반정규화의 기법
    1. 테이블 반정규화
        
        
        | 기법분류 | 기법 | 내용 |
        | --- | --- | --- |
        | 테이블병합 | 1:1 관계 테이블병합 | 1:1 관계를 통합하여 성능향상 |
        |  | 1:M 관계 테이블병합 | 1:M 관계를 통합하여 성능향상 |
        |  | 슈퍼/서브타입 테이블병합 | 슈퍼/서브 관계를 통합하여 성능향상 |
        | 테이블분할 | 수직분할 | 컬럼 단위의 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능향상(트랜잭션의 처리 유형 파악이 선행되어야 함) |
        |  | 수평분할 | 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블을 쪼갬(관계가 없음) |
        | 테이블추가 | 중복테이블 추가 | 다른 업무이거나 서버가 다른 경우를 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상 |
        |  | 통계테이블 추가 | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 |
        |  | 이력테이블 추가 | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법 |
        |  | 부분테이블 추가 | 하나의 테이블의 전체 컬럼 중 자주 이용하는 집중화된 컬럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성 |
    2. 컬럼 반정규화
    3. 관계 반정규화

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3f102ec4-125b-4831-99eb-3a488411198f/Untitled.png)

- 1) 과도한 조인으로 인해 성능이 저하됨

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fc75fc6e-299b-46f8-be70-073615e759d6/Untitled.png)

- 하나의 테이블에 많은 수의 컬럼이 존재하게 되면 데이터가 디스크의 여러 블록에 존재하므로 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하됨
- 물리적인 디스크에 여러 블록에 데이터가 저장됨
- 로우체이닝
    
    : 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
    
- 로우마이그레이션
    
    : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
    
- 로우 길이가 너무 긴 경우 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 불필요하게 I/O가 많이 발생할하여 성능이 저하됨

- 테이블에 컬럼수가 아주 많은 경우, 트랜잭션이 어떤 컬럼에 대해 집중적으로 발생하는지 분석하여 테이블을 쪼개주면 디스크 I/O가 감소하게 되어 성능이 개선됨

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b3dfbb7d-7f73-45dd-a54a-e6d20c9896d9/Untitled.png)

- 개별 테이블을 모두 조회하는 트랜잭션이 대부분이라는 가정이 있으므로 UNION/UNION ALL을 할 경우 개별조회에 따른 시간 소요와 조회한 결과를 조합하는 성능 저하가 발생됨
    
    → 하나의 테이블로 통합하고 대신 PK 체계나 일반속성에 각 사건을 구분할 수 있는 구분자를 부여해야 함
    

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1032ea5c-c33a-47d9-84e9-05cbe5cc3ec6/Untitled.png)

- 슈퍼/서브타입 데이터 모델의 변환
    1. 1:1 타입(One to One Type)
    2. 슈퍼 + 서브타입(Plus Type)
    3. All in One 타입(Single Type)

1. 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있음
2. 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터 때문에 성능이 저하됨
3. 트랜잭션은 항상 슈퍼+서브타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하됨