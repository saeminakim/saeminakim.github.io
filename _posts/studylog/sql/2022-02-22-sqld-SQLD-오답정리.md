---
layout: post
title: SQLD 오답 정리
slug: SQLD 오답 정리
categories: studylog
tags: SQL, SQLD
description: >
  SQL 오답 정리 
---
# SQLD 오답 정리

### 제2장. 데이터 모델과 성능

![E6446DDD-301D-477F-B9DE-49627ABBF2B5.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e10faaf4-1db6-445a-ade8-fa0490cc4ee9/E6446DDD-301D-477F-B9DE-49627ABBF2B5.jpeg)

- 성능 데이터 모델링
    
    : DB 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것
    
    : 분석/설계 단계에서 데이터 모델의 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화 할 수 있는 기회를 가지게 됨
    
    : 데이터 증가가 빠를수록 성능저하에 따른 성능개선비용은 기하급수적으로 증가하게 됨
    
    : 데이터 모델은 성능을 튜닝하면서 변경될 수 있는 특징이 있음
    
- 분석/설계 단계에서 진행하기 때문에 보기 1번의 ‘문제발생 시점’과는 무관

---

![F11981B8-454B-4F2C-83A9-380E628271EE.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cfdc0569-3bf9-4145-8c1d-0e15108c7af0/F11981B8-454B-4F2C-83A9-380E628271EE.jpeg)

- 성능 데이터 모델링 고려사항 순서
    
    : **정용 트반 구검**
    
    1. 데이터 모델링을 할 때 **정규화**를 정확하게 수행
    2. DB **용량산정**
    3. DB에 발생되는 **트랜잭션의 유형을 파악**
    4. 용량과 트랜잭선의 유형에 따라 **반정규화**를 수행
    5. 이력모델의 조정, PK/FK 조정, 슈퍼/서브타입 조정(**데이터 구조**)
    6. 성능관점에서 **데이터 모델 검증**

---

![FEEFF0D1-DCF6-4F9E-8EDA-0D4C2EDA4DA4.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24af76b0-577f-4af2-83d5-3f0551d7d1cc/FEEFF0D1-DCF6-4F9E-8EDA-0D4C2EDA4DA4.jpeg)

- **정용 트반 구검**

---

![25D2AECF-AEF2-486A-A1CA-CAE1A25D5FF3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/42694ded-462c-48be-a227-29a4ed8d8ac5/25D2AECF-AEF2-486A-A1CA-CAE1A25D5FF3.jpeg)

- 도부이결다조
- 보관금원장 엔터티에서 부분함수종속성을 제거해야 함 → 2정규화 필요

---

![171A563F-E1FB-4C26-9022-BC1FFEF86C7D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a796e9d5-fdd8-45fd-8db7-276a066a726d/171A563F-E1FB-4C26-9022-BC1FFEF86C7D.jpeg)

- 일단 1차 정규화 대상은 아님
- 일자별매각물건 엔터티의 매각시간, 매각장소 속성은 두 개의 주 식별자 속성 중 매각일자에만 종속되기 때문에 2차 정규화 대상
- 매각기일은 일자별매각물건의 주식별자 중 일부로부터 독립했기 때문에 매각기일과 일자별매각물건은 1:M 관계

---

![54068555-8129-4C1E-BF8B-93B180A833AC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c4c07c7-03a4-46e9-b800-db6ccfcdb5a5/54068555-8129-4C1E-BF8B-93B180A833AC.jpeg)

- 컬럼에 의한 반복적인 속성값을 갖는 형태는 속성의 원자성을 위반한 제 1차 정규화의 대상
- 이와 같은 반복적인 속성 나열 형태에서는 각 속성에 대해 ‘or’ 연산자로 연결된 조건들이 사용되는데, 이 때 어느 하나의 속성이라도 인덱스가 정의되어 있지 않게 되면 ‘or’로 연결된 모든 조건절들이 인덱스를 사용하지 않고 한 번의 전체 데이터 스캔으로 처리되게 되어 성능 저하가 나타날 수 있게 됨
- 또한 모든 반복 속성에 인덱스를 생성하게 되면 검색 속도는 좋아지겠지만 반대급부적으로 너무 많은 인덱스로 인해 입력, 수정, 삭제의 성능이 저하됨 → 1 정규화를 통해 문제 해결

---

![1F02CDA4-6E04-4957-B16F-00C0AC415421.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad7d4ded-680d-4d7a-8207-480b8db3bf40/1F02CDA4-6E04-4957-B16F-00C0AC415421.jpeg)

- 컬럼 단위에서 반복적 속성값을 갖는 형태 → 1 정규화 대상
- 일재고와 일재고상세는 1:M의 관계

---

![F2D85A25-F68D-41FC-ACDC-6CE51DEDF704.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ba093dbb-a78b-4567-86cb-83d0371a97fe/F2D85A25-F68D-41FC-ACDC-6CE51DEDF704.jpeg)

- 도부이결다조
- 부분 함수 종속성을 제거해야 하는 2차 정규화 대상

---

![9271BCEB-5B83-4979-B419-C183D077C625.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c93049ed-e187-4d1e-a6a9-11a62b4d7932/9271BCEB-5B83-4979-B419-C183D077C625.jpeg)

- 다량 데이터 탐색의 경우 인덱스가 아닌 파티션 및 데이터 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있음. 다만 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는 처리가 반복적으로 빈번하게 발생한다면 이때는 반정규화를 고려하는 것이 좋음
- 현재 레코드 기준 이전, 이후 레코드에 대한 탐색은 Window Function으로 가능
- 집계 테이블 이외에도 다양한 유형(다수 테이블의 키 연결 테이블 등)에 대하여 반정규화 테이블 적용이 필요할 수 있음

---

![752FC3AE-C206-4AE8-859F-22A63679A723.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e962d87-414c-4e48-9086-32b3ba374345/752FC3AE-C206-4AE8-859F-22A63679A723.jpeg)

- 반정규화의 기법 : 테이블, 칼럼, 관계
- 테이블 반정규화(**병분추**)
    - 테이블 **병**합
        - 1:1관계
            
            : 1:1 관계를 통합하여 성능향상
            
        - 1:M관계
            
            : 1:M 관계를 통합하여 성능향상
            
        - 슈퍼/서브타입
            
            : 슈퍼/서브 관계를 통합하여 성능향상
            
    - 테이블 **분**할
        - 수직분할
            
            : 칼럼 단위 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능향상
            
        - 수평분할
            
            : 로우단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우 단위로 테이블을 쪼갬
            
    - 테이블 **추**가
        - 중복
            
            : 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능 향상
            
        - 통계
            
            : SUM, AVG 등을 미리 수행하여 계산해둠으로써 조회 성능 향상
            
        - 이력
            
            : 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
            
        - 부분
            
            : 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성
            
- 칼럼 반정규화(**중파이 임기**)
    - **중**복
        
        : 조인에 의해 처리할 때 성능저하를 예방하기 위해 중복된 칼럼을 위치시킴
        
    - **파**생
        
        : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관
        
    - **이**력테이블
        
        : 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함
        
    - 응용시스템 오작동을 위한 칼럼 추가(**임**시)
        
        : 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
        
    - PK에 의한 칼럼 추가(**기**본키)
        
        : 이미 PK안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법
        
- 관계 반정규화
    - 중복관계 추가
        
        : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법
        

---

![A9C84195-BB5B-4B77-91A0-D91A2CE5A8BC.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f16d1224-11ff-4385-91c4-96c34445899c/A9C84195-BB5B-4B77-91A0-D91A2CE5A8BC.jpeg)

- 칼럼 반정규화(**중파이 임기**)
    - **중**복
        
        : 조인에 의해 처리할 때 성능저하를 예방하기 위해 중복된 칼럼을 위치시킴
        
    - **파**생
        
        : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관
        
    - **이**력테이블
        
        : 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함
        
    - 응용시스템 오작동을 위한 칼럼 추가(**임**시)
        
        : 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
        
    - PK에 의한 칼럼 추가(**기**본키)
        
        : 이미 PK안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법
        

---

![335D7A58-8449-4A2B-BEE7-43009E7D6CE8.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb964b4f-e608-441d-8419-2ac1f87147da/335D7A58-8449-4A2B-BEE7-43009E7D6CE8.jpeg)

- 최근에 변경된 값만을 조회할 경우 과도한 조인으로 이해 성능이 저하되어 나타나게 됨

---

![0FAA4D76-ED02-491C-BF6E-4784BB0D200D.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23efdd18-ceb0-467c-b63c-a9b124a0804e/0FAA4D76-ED02-491C-BF6E-4784BB0D200D.jpeg)

- 한 테이블에 많은 칼럼들이 존재할 경우 데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 디스크 I/O가 대량으로 발생 → 성능 저하 가능성 높아짐
- 따라서 트랜잭션이 접근하는 칼럼유형을 분석해서 자주 접근하는 칼럼들과 상대적으로 접근 빈도가 낮은 칼럼들을 구분하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어듦 → 성능 향상

---

![70931AB5-9838-4F05-ACEB-D1412A980571.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7d89f33-5b76-456f-923a-5c0f74a70e33/70931AB5-9838-4F05-ACEB-D1412A980571.jpeg)

- 파티셔닝
    - 서비스의 크기가 커지고 DB에 저장하는 데이터의 규모 또한 커지면서 기존 DB의 용량의 한계와 성능 저하 발생
    - 이를 해결하기 위해 테이블을 ‘파티션(partition)’이라는 작은 단위로 나누어 관리하는 기법 → 파티셔닝
    - 논리적인 데이터 element를 관리하기 쉬운 파티션이라는 작은 단위로 물리적으로 분할하는 것
    - 이 때, 물리적인 데이터 분할이 있더라도 DB에 접근하는 application의 입장에서는 이를 인식하지 못함

---

![FBF520D3-3804-4935-9C34-AB7D467E156E.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e2b0d9a-2a19-4fc3-bd6a-431dc2b21ac7/FBF520D3-3804-4935-9C34-AB7D467E156E.jpeg)

- 개별 테이블을 모두 조회하는 트랜잭션이 대부분이라고 주어짐 → UNION/UNION ALL 모두 개별조회에 따른 시간소요와 이를 조합하는 성능저하가 발생됨
- 따라서 하나의 테이블로 통합하고 대신 PK체계나 일반속성에 각 사건을 구분할 수 있도록 구분자를 부여하는 게 좋음

---

![4CFA9DD4-2EA9-4C81-843E-6B64E258A1BD.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3123b069-8528-497d-b59e-8708e0b490a1/4CFA9DD4-2EA9-4C81-843E-6B64E258A1BD.jpeg)

- 슈퍼/서브 타입 데이터 모델의 변환 시 성능이 저하되는 경우
    1. 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있음
    2. 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하되는 경우가 있음
    3. 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우가 있음

---

![2796B827-FAFE-4654-9315-800C4804ECEA.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/49b8149a-1901-4df8-9da3-93e0cf9abd7b/2796B827-FAFE-4654-9315-800C4804ECEA.jpeg)

- 인덱스는 값의 범위에 따라 일정하게 정렬이 되어 있으므로 상수값으로 EQUAL 조건으로 조회되는 칼럼이 가장 앞으로 나오고 범위조회 하는 유형의 칼럼이 그 다음에 오도록 하는 것이 인덱스 액세스 범위를 좁힐 수 있는 가장 좋은 방법이 됨

---

![AF297D2C-0740-4C5B-A1BD-ECABCFA95B00.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4b15ee5-ac85-4e9f-9351-1bb06f02bd96/AF297D2C-0740-4C5B-A1BD-ECABCFA95B00.jpeg)

- EQUAL 조건(=)에 해당하는 칼럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장 높음

---

![962DEA30-6A20-4AD9-BA22-96150C5F992F.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e1b58af-f384-4f70-8ae2-5e9d0fe4850d/962DEA30-6A20-4AD9-BA22-96150C5F992F.jpeg)

- 엔터티 간에 논리적 관계가 있을 경우 즉, 엔터티 간에 관계를 정의하여 관련 엔터티 상호간에 업무적인 연관성이 있음을 표현한 경우에는, 이 데이터들이 상호간에 조인이 자주 발생한다는 것을 의미
    
    → FK 제약을 생성했는지 여부와 상관없이 조인 성능을 향상시키기 위해 인덱스를 생성해주는 것이 좋음
    
- 물리적인 테이블에 FK 제약 걸었을 때는 반드시 FK 인덱스를 생성하도록 하고, FK 제약이 걸리지 않았을 경우에는 FK 인덱스를 생성하는 것을 기본정책으로 하되 발생되는 트랜잭션에 의해 거의 활동되지 않았을 때에만 FK 인덱스를 지우는 방법으로 하는 것이 적절한 방법

---

![A9C353A2-E736-458F-ACCD-700155C30F28.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af08528f-dae1-4a12-a31a-166ef8966c2a/A9C353A2-E736-458F-ACCD-700155C30F28.jpeg)

- 분산DB
    
    : 여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB
    
    : 논리적으로 동일한 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터집합
    

- 마스터 데이터를 한 곳에 두고 운영하는 경우 원격지에서의 접근이 빈번할수록 실시간 업무처리에 대해 좋은 성능을 얻기가 어려울 수 있기 때문에 분산 환경에서 복제분산을 하는 방법으로 분산 DB를 구성
- 또한 백업 사이트 구성에 대해서도 분산 환경으로 구성하여 적용 가능
- GSI는 통합된 한 개의 인스턴스, 즉 통합 데이터베이스 구조를 의미하므로 분산 DB와는 대치되는 개념